name: Prune Image

on:
  pull_request:
    types: [closed]

jobs:
  print-details:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    env:
      PR_NUMBER: ${{ github.event.number }}
      PR_MERGED_BRANCH: ${{ github.event.pull_request.base.ref }}
      PR_SOURCE_BRANCH: ${{ github.event.pull_request.head.ref }}

    permissions:
      contents: read
      packages: read

    steps:
      - name: Print PR info
        run: |
          echo "PR Number: $PR_NUMBER"
          echo "Merged into branch: $PR_MERGED_BRANCH"
          echo "Merged from branch: $PR_SOURCE_BRANCH"

      - name: Get previous package
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.PAT_PRUNE }}
          script: |
            const { owner, repo } = context.repo;

            const delete_pkg = async (pkg) => {
              try {
                /**
                * @link https://octokit.github.io/rest.js/v22/#packages-delete-package-version-for-authenticated-user
                */
                const response = await github.rest.packages.deletePackageVersionForAuthenticatedUser({
                  package_type: 'container',
                  package_name: repo,
                  package_version_id: pkg.id,
                });

                core.info(`Deleted image: ${pkg.digest}`);
              } catch (error) {
                core.warning(`Unable to delete package ${pkg.digest}: ${error.message}`);
              }
            }

            try {
              const packages = [];
              const per_page = 50;
              let has_next = true;
              let page = 1;

              do {
                /**
                 * @link https://octokit.github.io/rest.js/v22/#packages-get-all-package-versions-for-a-package-owned-by-the-authenticated-user
                 */
                const { data } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByAuthenticatedUser({
                  package_type: 'container',
                  package_name: repo,
                  per_page,
                  page,
                });

                for (const { metadata, ...pkg } of data) {
                  packages.push({
                    id: pkg.id,
                    url: pkg.url,
                    digest: pkg.name,
                    ...metadata.container,
                    created_at: pkg.created_at,
                  });
                }

                has_next = data.length === per_page;
                page++;
              } while (has_next);

              const reduced = packages.reduce((pkgs, pkg) => {
                let tag = 'untagged';

                if (pkg.tags.length > 0) {
                  const image_tag = pkg.tags.find(tag => /^\d+\.\d+\.\d+-[\w-]+\.[a-f0-9]{8}$/.test(tag));
                  tag = image_tag.replace(/^\d+\.\d+\.\d+-(.*)\.[a-f0-9]{8}$/, '$1');
                }

                tag = tag.trim();
                pkgs[tag] = pkgs[tag] || [];

                if (pkgs[tag].find(p => p.id === pkg.id)) {
                  // Skip it due to duplicate ID
                  return pkgs;
                }

                pkg.latest = pkg.tags.includes('latest');
                pkgs[tag].push(pkg);

                return pkgs;
              }, {})

              // Images to delete
              const to_delete = reduced.untagged || [];

              // Keep last 5 main images
              if (reduced.main && reduced.main.length > 5) {
                // Sort by created_at descending (newest first) to keep recent images
                reduced.main.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                to_delete.push(...reduced.main.slice(5));
              }

              for (const [tag, pkgs] of Object.entries(reduced)) {
                console.info(tag, ':', pkgs.length);

                // Delete images other than main and untagged
                if (pkgs.length > 0 && !['main', 'untagged'].includes(tag)) {
                  to_delete.push(...pkgs);
                }
              }

              if (to_delete.length === 0) {
                core.info('No images to delete');
                return;
              }

              await Promise.all(to_delete.map(delete_pkg));
            } catch (error) {
              console.error(error);
            }
